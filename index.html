<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>I. express简介</title>
		<style>
			
img {
  max-width: 90%;
  margin: 0 auto;
}

.remark-slide-scaler {
  left: 50%;
  width: 90%;
  transform: translateX(-50%);
}

.remark-slide-content {
  padding: 1em 3em;
  position: relative;
}
.remark-slide-content::after {
  content: "";
  display: inline-block;
  width: 288px;
  height: 76px;
  background: url('logo.png') no-repeat 50% 50%;
  position: absolute;
  right: 50px;
  bottom: 50px;
  z-index: 0;
  filter: blur(10);
  opacity: .1;
}

.remark-slides-area>div:first-of-type .remark-slide-content {
  text-align: center;
  padding: .5em;
}
.remark-slides-area>div:first-of-type .remark-slide-content::after {
  display: none;
}
		</style>
	</head>
	<body>
		<textarea id="source">

- [Node.js](https://nodejs.org/zh-cn/) 《Node.js 官网（中文）》
- [Node.js](https://nodejs.org/en/) 《Node.js 官网（英文）》

<br/><br/>

**Node.js 是什么**

>Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js' package ecosystem, npm, is the largest ecosystem of open source libraries in the world.

    1. JavaScript 运行时
    2. 既不是语言，也不是框架，它是一个平台

**Node.js 中的 JavaScript**

    1. 没有 BOM、DOM
    2. 在 Node 中为 JavaScript 提供了一些服务器级别的 API
        2.1 fs 文件操作模块
        2.2 http 网络服务构建模块
        2.3 os 操作系统信息模块
        2.4 path 路径处理模块
        2.5 .....

---

<!-- markdown-to-slides share1.md -o index.html -s slide.css -->

## I. express简介

基于 Node.js 平台，快速、开放、极简的 Web 开发框架

简单来说，封装了node中http核心模块，专注于业务逻辑的开发。

安装方法

```javascript

npm install express --save

```
---

Hello World

```javascript

var express = require('express')

var app = express()

app.get('/', function (req, res) {
  res.send('hello world ...')
})

app.listen(3000, function () {
  console.log('express app is runing .....')
})

```
Hello World 测试结果：

<img src="http://img1.ph.126.net/4rbKjFebIGFp27lrwJziag==/6631702183913005570.png" height="200" width="600" />


---

### express 路由

Routing refers to how an application’s endpoints (URIs) respond to client requests. 

 -请求方法

 -请求路径

 -请求处理函数

**公开静态资源**

```javascript

// 访问路径 http://127.0.0.1:3000/a.js
app.use(express.static('./public/'))

// 访问路径 http://127.0.0.1:3000/public/a.js
app.use('/public/',express.static('./public/'))

```



---

### require 方法的加载规则

-[深入浅出 node.js](http://www.infoq.com/cn/articles/nodejs-module-mechanism/)

**node 中存在的模块主要有：**

1. 核心模块 path fs http ...
2. 自己定义的模块 （路径形式的模块）
3. 第三方模块 art-template express（使用npm安装的模块）

```javascript

// 加载核心模块
const path = require('path');

// 加载自定义模块
const foo = require('./fooo.js')

// 加载第三方模块 node_modules
const express = require('express')

```
---

**node 中require加载规则：**
1. 优先缓存加载

2. 判断模块标识

  2.1 是否是核心模块 http 、fs 加载 缓存 export

  2.2 是否是文件模块 ./foo.js 加载 缓存 export

  2.3 是否是第三方模块 （第三方模块需要 npm install 安装）

      - node_modules/art-template/
      - node_modules/art-template/package.json
      - node_modules/art-template/package.json 中找main 作为文件加载入口
      - index.js 备选项
      - 进入上一级目录找 node_modules
      - 按照此规则依次向上查找，直到磁盘根目录找不到 报错 Can not find moudle XXX

---

node 中require加载规则：

<img src="http://img1.ph.126.net/rbUZEFX4o6NnLcfrgNXomA==/1910933616989134372.jpg" height="540" width="300" />
<img src="http://img2.ph.126.net/h8Kc7evXazduSR-lOYWnEw==/6597311659217060144.jpg" height="540" width="400" style="margin-left:60px"/>

---

### nodemon 

[nodemon](https://nodemon.io/)《nodemon使用方法》

> nodemon reload, automatically

nodemon用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中

```javascript

// 全局安装nodemon
npm install -g nodemon

nodemon app.js

```

---

### 中间件 body-parser  

**express中没有内置的获取表单请求体的API，所以需要第三方包解析HTTP请求体**

This module provides the following parsers:

1. JSON body parser
2. Raw body parser
3. Text body parser
4. URL-encoded form body parser

使用方法：

```javascript

const bodyParser = require('body-parser');
const app = express();

app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());
app.use(function(req, res, next) {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
  next();
});

```
---

```javascript
router.post('/students/new', function (req, res) {
  console.log(req.body)
  Student.save(req.body, function (err) {
    if (err) {
      return res.status(500).send('Server error.')
    }
    res.redirect('/students')
  })
})

```
post 提交方式测试：

<img src="http://img1.ph.126.net/82CmNmtkr5WCSGocf-7a_Q==/759138012289304338.png" width="350"  />
<img src="http://img1.ph.126.net/wSMCvySXI6jDnIyWpsvkvg==/1669428086971567957.png"  width="350" style="margin-left:40px"/>

---

### package-lock.json

npm 5以前没有 package-lock.json 文件

1. 安装包时不需要加 --save参数 会自动保存依赖信息
2. 在安装包时，会自动更新package-lock.json文件
3. package-lock.json文件保存node_molules中所有包信息（记录版本号和下载地址等信息）

---

### 断言库

断言库主要提供上述断言的语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 Should.js, Chai.js 等。

---

### 测试用例 test case

为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。

一般的形式为：

```javascript
it('should ...', function() {
  ...
    
  expect(sth).toEqual(sth);
});
```

---

### 测试套件 test suite

通常把一组相关的测试称为一个测试套件

一般的形式为：

```javascript
describe('test ...', function() {
  
  it('should ...', function() { ... });
  
  it('should ...', function() { ... });
  
  ...
  
});
```

---

### spy

> 正如 `spy` 字面的意思一样，我们用这种“间谍”来“监视”函数的调用情况

通过对监视的函数进行包装，可以通过它清楚的知道该函数被调用过几次、传入什么参数、返回什么结果，甚至是抛出的异常情况。

```
var spy = sinon.spy(MyComp.prototype, 'someMethod');

...

expect(spy.callCount).toEqual(1);
```

---

### stub

> 有时候会使用`stub`来嵌入或者直接替换掉一些代码，来达到隔离的目的

一个`stub`可以使用最少的依赖方法来模拟该单元测试。比如一个方法可能依赖另一个方法的执行，而后者对我们来说是透明的。好的做法是使用stub 对它进行隔离替换。这样就实现了更准确的单元测试。

```
var myObj = {
  prop: function() {
    return 'foo';
  }
};

sinon.stub(myObj, 'prop').callsFake(function() {
    return 'bar';
});

myObj.prop(); // 'bar'
```

---

### mock

`mock`一般指在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法

广义的讲，以上的 spy 和 stub 等，以及一些对模块的模拟，对 ajax 返回值的模拟、对 timer 的模拟，都叫做 mock 。

---

### 测试覆盖率(code coverage)

用于统计测试用例对代码的测试情况，生成相应的报表，比如 `istanbul` 是常见的测试覆盖率统计工具。

<img src="
https://user-gold-cdn.xitu.io/2018/10/25/166a6d35efe402b0?w=1190&h=490&f=png&s=97141)" />

- 语句覆盖率（statement coverage）：是否每个语句都执行了
- 分支覆盖率（branch coverage）：是否每个`if`代码块都执行了
- 函数覆盖率（function coverage）：是否每个函数都调用了
- 行覆盖率（line coverage）：是否每一行都执行了

---

## II. Vue.js 中的单元测试工具

---

### 2.1 Jest

<img src="https://user-gold-cdn.xitu.io/2018/10/25/166a6d3102e7b9e1" alt="jest" width="300" />

Jest 是一个由 Facebook 开发的测试运行器，相对其他测试框架，其特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。

此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。

---

#### 配置 Jest

可以零配置，只需在 `npm scripts`里面配置了`test: jest`，即可运行`npm test`，自动识别并测试符合其规则的（ Vue.js 项目中一般是 `__tests__` 目录下的）用例文件。

也可以在 package.json 的 jest 字段或独立的 jest.config.js 里自定义配置。

---

#### 四个基础单词

编写单元测试的语法通常非常简单；对于`jest`来说，由于其内部使用了 `Jasmine 2` 来进行测试，故其用例语法与 Jasmine 相同。

实际上，只要先记这住四个单词，就足以应付大多数测试情况了：

- `describe`： 定义一个测试套件
- `it`：定义一个测试用例
- `expect`：断言的判断条件
- `toEqual`：断言的比较结果

```
describe('test ...', function() {
  it('should ...', function() {
    expect(sth).toEqual(sth);
    expect(sth.length).toEqual(1);
    expect(sth > oth).toEqual(true);
  });
});
```

---

### 2.2 sinon

<img src="https://sinonjs.org/assets/images/logo.png" alt="sinon" width="200" />
<img src="https://user-gold-cdn.xitu.io/2018/10/25/166a6d318ed7742e?w=914&h=868&f=jpeg&s=752425" alt="sinon" width="300" />

各种伪装渗透方法的合集，为单元测试提供了独立而丰富的 spy, stub 和 mock 方法，兼容各种测试框架。

虽然 Jest 本身也有一些实现 spy 等的手段，但 sinon 使用起来更加方便。

---

### 2.3 Vue Test Utils

> Vue Test Utils 是 Vue.js 官方的单元测试实用工具库；该工具库使用起来和用以测试 React 组件的 Enzyme 工具库非常相似

它模拟了一部分类似 jQuery 的 API，非常直观并且易于使用和学习，提供了一些接口和几个方法来减少测试的样板代码，方便判断、操纵和遍历 Vue Component 的输出，并且减少了测试代码和实现代码之间的耦合。

一般使用其 `mount()` 或 `shallowMount()` 方法，将目标组件转化为一个 `Wrapper` 对象，并在测试中调用其各种方法，例如：

```javascript
import { mount } from '@vue/test-utils'
import Foo from './Foo.vue'

describe('Foo', () => {
  it('renders a div', () => {
    const wrapper = mount(Foo)
    expect(wrapper.contains('div')).toBe(true)
  })
})
```

---

## III. 更多 Vue.js 的单元测试实例

[CabinetVisual.js](http://git.jd.com/CCS/ccs-console-web/blob/master/__tests__/components/cabinetVisual/CabinetVisual.js)

[NotI18n.js](http://git.jd.com/CCS/ccs-console-web/blob/master/__tests__/components/common/NotI18n.js)

---

### 整合到工作流中

写好的单元测试，如果仅仅要靠每次 `npm test` 手动执行，必然会有日久忘记、逐渐过时，最后甚至无法执行的情况。

有多个时间点可以作为选择，插入自动执行单元测试 -- 例如每次保存文件、每次执行 build 等

也可以在项目中安装 `pre-commit` 依赖包；然后在 `package.json` 中配置 npm scripts ：

```json
"scripts": {
  ...
  "test": "jest"
},
"pre-commit": [
  "test"
],
```

---


## IV. 用单元测试改善 Vue.js 组件

单元测试除了减少错误，另一个显著的好处是能让我们组件化的思路越来越清晰，养成日益良好的习惯。

- 单元测试保证了每次对组件做出的更改后，组件都能正确工作

- 单元测试另一个重要的方面是用其检验组件架构化水平优劣的能力

- 设计不佳的组件无法测试，对其更新就会造成更多的功能处于失控状态，形成恶性循环

---

### 一个封装不好的组件

假设要对 NumStepper.vue 组件进行测试

<img src="
https://user-gold-cdn.xitu.io/2018/10/25/166a6d61f56316dc?w=1140&h=702&f=png&s=84971)" />

---

```javascript
//NumStepper.vue

<template>
  <div>
    <button class="plus" v-on:click="updateNumber(+1)">加</button>
    <button class="minus" v-on:click="updateNumber(-1)">减</button>
    <button class="zero" v-on:click="clear">清</button>
  </div>
</template>

<script>
export default {
  props: {
    targetData: Object,
    clear: Function
  },
  methods: {
    updateNumber: function(n) {
      this.targetData.num += n;
    }
  }
}
</script>
```

---

该组件又依赖一个外层组件给其提供数据和方法：

```javascript
//NumberDisplay.vue
<template>
  <div>
    <p>{{somedata.num}}</p>
    <NumStepper :targetData="somedata" :clear="clear" />
  </div>
</template>
<script>
import NumStepper from "./NumStepper"
export default {
  components: {
    NumStepper
  },
  data() {
    return {
      somedata: {
        num: 999
      },
      tgt: this
    }
  },
  methods: {
    clear: function() {
      this.somedata.num = 0;
    }
  }
}
</script>
```

---

这样一来，测试就得这样写：

```javascript
import { shallowMount } from "@vue/test-utils";
import Vue from 'vue';
import NumStepper from '@/components/NumStepper';
import NumberDisplay from '@/components/NumberDisplay';

describe("测试 NumStepper 组件", ()=>{
  it("应该能够影响外层组件的数据", ()=>{
    const display = shallowMount(NumberDisplay);
    const wrapper = shallowMount(NumStepper, {
      propsData: {
        targetData: display.vm.somedata,
        clear: display.vm.clear
      }
    });

    expect(display.vm.somedata.num).toBe(999);

    wrapper.find('.plus').trigger('click');
    wrapper.find('.plus').trigger('click');
    expect(display.vm.somedata.num).toBe(1001);

    wrapper.find('.minus').trigger('click');
    expect(display.vm.somedata.num).toBe(1000);

    wrapper.find('.zero').trigger('click');
    expect(display.vm.somedata.num).toBe(0);
  })
});
```

---

`<NumStepper>` 测试起来非常复杂，因为它关联了外部组件的实现细节。

测试场景中需要一个额外的 `<NumberDisplay>` 组件，用来重现外部组件、向目标组件传递数据和方法，并检验目标组件是否正确修改了外部组件的状态。

假如 `<NumberDisplay>` 组件再依赖其他组件或环境变量、全局方法等，事情将变得更糟糕，可能需要单独实现若干测试专用组件，甚至根本无法测试。

---

### 改善后的组件

当 `<NumStepper>` 独立于外部组件的细节时，测试就简单了
  
```javascript
//NumStepper2.vue

<template>
  <div>
    <button class="plus" v-on:click="updateFunc(+1)">加</button>
    <button class="minus" v-on:click="updateFunc(-1)">减</button>
    <button class="zero" v-on:click="clearFunc">清</button>
  </div>
</template>

<script>
export default {
  props: {
    updateFunc: Function,
    clearFunc: Function
  }
}
</script>
```

---

在测试中，就不用引入额外的组件了：

```javascipt
import { shallowMount } from "@vue/test-utils";
import Vue from 'vue';
import NumStepper from '@/components/NumStepper2';

describe("测试 NumStepper 组件", ()=>{
  it("应该能够影响外层组件的数据", ()=>{
    const obj = {
      func1: function(){},
      func2: function(){}
    };
    const spy1 = jest.spyOn(obj, "func1");
    const spy2 = jest.spyOn(obj, "func2");

    const wrapper = shallowMount(NumStepper, {
      propsData: {
        updateFunc: spy1,
        clearFunc: spy2
      }
    });
    wrapper.find('.plus').trigger('click');
    expect(spy1).toHaveBeenCalled();
    wrapper.find('.minus').trigger('click');
    expect(spy1).toHaveBeenCalled();
    wrapper.find('.zero').trigger('click');
    expect(spy2).toHaveBeenCalled();
  })
});
```

---

## V. 总结

单元测试作为一种经典的开发和重构手段，在软件开发领域被广泛认可和采用；前端领域也逐渐积累起了丰富的测试框架和方法。

单元测试可以为我们的开发和维护提供基础保障，使我们在思路清晰、心中有底的情况下完成对代码的搭建和重构。

封装好则测试易，反之不恰当的封装让测试变得困难。

可测试性是一个检验组件结构良好程度的实践标准。






		</textarea>
		<script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
		<script>
			var slideshow = remark.create();
		</script>
		<script></script>
	</body>
</html>
